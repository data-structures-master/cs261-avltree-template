# AVL Tree: An AVL tree is a self-balancing tree.
# Implement as many operations as possible with recursion.
# If you can't figure it out recursively, use a loop. (But then refactor
# your implementation into a recursive one!)
# Your implementation should pass the tests in test_avl.py.

# Name:
# Collaborators:
# Time spent:

# Note:  BST insert and delete methods have been provided for your convenience. Uncomment and modify




class FixMe:
    pass
    
    # def insert(self, node):
    #     if node.key>self.key:
    #         if self.right is None:
    #             self.right=node
    #         else:
    #             self.right=self.right.insert(node) 
    #     else:
    #         if self.left is None:
    #             self.left=node
    #         else:
    #             self.left=self.left.insert(node)

    
    # def delete(self, key):
    #     if self.key == key:
    #         if self._has_left_child() and self._has_right_child():
    #             new_root= self.right._minimum()
    #             self.right= self.right.delete(new_root.key)
    #             new_root.right= self.right
    #             new_root.left= self.left
    #             return new_root
    #         if self._has_left_child():
    #             return self.left
    #         elif self._has_right_child():
    #             return self.right
    #         return None 
    #     else:
    #         if key <= self.key:
    #             if self._has_left_child():
    #                 self.left= self.left.delete(key)
    #         else:
    #             if self._has_right_child():
    #                 self.right= self.right.delete(key) 

          
